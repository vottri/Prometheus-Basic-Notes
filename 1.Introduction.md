# Introdcution to Prometheus

Prometheus is an open-source monitoring and alerting tool designed to collect data about applications and systems. It also allows you to present that collected data in various forms, such as charts and graphs as well as issue real-time alerts to the relevant recipient when conditions are met.

# Metrics

The data about systems and applications that you want Prometheus to monitor (CPU status, memory usage, request times, active connections, ...) is called a metric. Prometheus collects those metric data from monitoring targets (servers, databases, containers, applications, ...) throughout your system over time and stores them in one place (locally or remotely).

In a little more detail, Prometheus collects and stores its metrics as time-series data (metrics information is stored along with the timestamp at when it was recorded) in a storage called time-series database (designed for time-series data). In its most basic form, a metric data point is made of: A metric name, The timestamp when the data point was collected, A measurement represented by a numeric value.

# Prometheus Architecture

Monitoring is an important aspect of DevOps practices. In order to manage a big and complex system, you need to be able to quickly see what is happening in your systems. And through monitoring and collection of metric data, Prometheus allows you to do that. Those metrics provide insight into the behavior and health of your systems. Because if someone comes up to you and says the system is slow, you will need some informations to find out what is happening with it.

Here, we dive a little bit into the basic architecture of Prometheus and how it uses a pull model to collect metrics from its monitoring targets. Then, we'll explore how to produce metrics from Linux and Windows servers using an exporter and from custom applications using a client library, and how to configure Prometheus to fetch those metrics. 


A central server that handles collecting and storing metric data.

Prometheus is a system that collects metrics. It fetch metrics by sending a HTTP request called a "scrape". 

Prometheus periodically scrapes HTTP endpoints (targets) to retrieve metrics. Those targets are Prometheus monitoring targets, such as servers, databases, containers, applications, ... 

Scrapes happen regularly at given intervals; usually you would configure it to happen every 30 to 60 seconds for each target. Those are set up using one or more "scrape config" directives, which are handled via a YAML configuration file.

Once an endpoint is available (the metrics from your systems and applications has been exposed), Prometheus can start scraping, capture metrics as a time series, and store all those metrics in a time series database, which is also running in the server.

Time series data just means that all the metrics are recorded with a timestamp, so it can be easily queried using time ranges.






• Alertmanager - Sends alerts triggered by metric data to external system, such as: email, Slack, PagerDuty, ...).
The Alertmanager receives alerts from Prometheus servers and turns them into notifications. Notifications can include email, chat applications such as Slack, and services such as PagerDuty.


• Web UI & Visualization Tools - Provide useful ways to view metric data in a chart or graph form over time. However, Grafana are advised for actual graphs.
It is recommended that you use Grafana for dashboards. It has a wide variety of features, including official support for Prometheus as a data source. It can produce a wide variety of dashboards,



 The scraped data is stored, and you can use it in dashboards using PromQL or send alerts to the Alertmanager, which will convert them into pages, emails, and other notifications.
 
 
Once an endpoint is available (the metrics from your systems and applications has been exposed), Prometheus can start scraping, capture metrics as a time series, and store it in a database designed for time-series data. 

• Exporters:

Any system that you want Prometheus to monitor needs to run an exporter, which provides all its metrics in an HTTP endpoint, Prometheus server grabs the metrics from that endpoint on a schedule and then it stores them. The job of the exporter is to provide metrics, which are relevant to that system in the format Prometheus can read.

Exporters can add metrics to systems which don't have Prometheus support and make them available for collection by the Prometheus server.

Prometheus collects metrics mainly using a pull model. This means Prometheus server pulls metric data from exporters — agents do not push data to the Prometheus server.
  
For every major DevOps tool on the market, there is a specific exporter that exposes data in a format Prometheus can read. The most common of these is the Node Exporter and Windows Exporter, used to expose system metrics (operating system and hardware).

• Client Libraries:

Client Libraries can turn your custom applications into an exporter that exposes metrics in a format Prometheus can collect. With usually only two or three lines of code, you can embed Prometheus support in your own applications using client libraries.  

All the major languages have Prometheus client libraries, you can add those libraries to your applications and get runtime metrics for free, and easily add code to record your own custom application metrics. 

The combination of the lightweight server and the wide range of exporters and client libraries means you can pretty much monitor your whole stack, and have the same monitoring solution running in every environment.


