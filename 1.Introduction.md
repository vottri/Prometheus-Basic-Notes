# Introdcution to Prometheus

Prometheus is an open-source monitoring and alerting tool designed to collect data about applications and systems. It also allows you to present that collected data in various forms, such as charts and graphs as well as issue real-time alerts to the relevant recipient when conditions are met.

# Metrics

The data about systems and applications that you want Prometheus to monitor (CPU status, memory usage, request times, active connections, ...) is called a metric. Prometheus collects those metric data from monitoring targets (servers, databases, containers, applications, ...) throughout your system over time and stores them in one place (locally or remotely).

In a little more detail, Prometheus collects and stores its metrics as time-series data (metrics information is stored along with the timestamp at when it was recorded) in a storage called time-series database (designed for time-series data). In its most basic form, a metric data point is made of: A metric name, The timestamp when the data point was collected, A measurement represented by a numeric value.

Monitoring is an important aspect of DevOps practices. In order to manage a big and complex system, you need to be able to quickly see what is happening in your systems. And through monitoring and collection of metric data, Prometheus allows you to do that. Those metrics provide insight into the behavior and health of your systems. Because if someone comes up to you and says the system is slow, you will need some informations to find out what is happening with it.

# Prometheus Architecture

Prometheus consists of a variety of components, but the 2 most basic components of any Prometheus system are the Prometheus server and exporters.

## Prometheus server:

A central server that handles gathering and storing metric data.

Actually, Prometheus runs a whole lot of functions inside one server. 

One of them is a scheduler component which fetches metrics from the systems that you want to monitor (Prometheus calls those systems the targets, and the act of collecting the metrics is called scraping).

Prometheus uses a pull model, so you need to expose metrics from your systems, and then Prometheus will periodically go and scrape them. Scrapes happen regularly at given intervals; usually you would configure it to happen every 30 to 60 seconds for each target.

Everything about the systems that you want to monitor is stored in the Prometheus configuration file, which uses the YAML format. In there, you tell Prometheus how to find the targets, how often it should scrape them, and what it should do which the metrics it scrapes.

After scraping them, Prometheus store all those metrics in a time series database, which is also running in the server. Time series data just means that all the metrics are recorded with a timestamp, so it can be easily queried using time ranges.

Once the scraped metric is stored, you can queries them using PromQL. Prometheus has its own query language, because time series data doesn't really fit well with standard SQL. Also there's an HTTP API running in the Prometheus server, which lets you run those queries and see the current values of metrics or have them visualized in a graph over time. But the Prometheus UI isn't a fully featured dashboard, it is recommended that you use Grafana for dashboards and actual graphs. 

Lastly, Prometheus has a really advanced alerting system. You register alerting rules in the Prometheus server, and when the rules trigger, Prometheus can send alerts to the Alert Manager, which will then turns them into notifications. Notifications can include email, chat applications such as Slack, and services such as PagerDuty, ...

## Exporters:

Any system that you want Prometheus to monitor needs to run an exporter, which provides all its metrics in an HTTP endpoint, Prometheus server then grabs the metrics from that endpoint on a schedule and then it stores them. The job of the exporter is to provide metrics, which are relevant to that system in the format Prometheus can read.

Prometheus collects metrics mainly using a pull model. This means Prometheus server pulls metric data from exporters. do not push data to the Prometheus server.
  So the Prometheus server is going to collect
metrics using that pull data
by making requests to them.
Our exporters are over there on the left.
These are different systems and applications
that are providing data,
which the Prometheus server is then able to pull.
And it's going to periodically make requests
to those exporters in order to pull new data.
For every major DevOps tool on the market, there is a specific exporter that exposes data in a format Prometheus can read. The most common of these is the Node Exporter and Windows Exporter, used to expose system metrics (operating system and hardware).

â€¢ Client Libraries:

Client Libraries can turn your custom applications into an exporter that exposes metrics in a format Prometheus can collect. With usually only two or three lines of code, you can embed Prometheus support in your own applications using client libraries.  

All the major languages have Prometheus client libraries, you can add those libraries to your applications and get runtime metrics for free, and easily add code to record your own custom application metrics. 

The combination of the lightweight server and the wide range of exporters and client libraries means you can pretty much monitor your whole stack, and have the same monitoring solution running in every environment.


Here, we dive a little bit into the basic architecture of Prometheus and how it uses a pull model to collect metrics from its monitoring targets. Then, we'll explore how to produce metrics from Linux and Windows servers using an exporter and from custom applications using a client library, and how to configure Prometheus to fetch those metrics. 
