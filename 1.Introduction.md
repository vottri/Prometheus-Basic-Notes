# Introdcution to Prometheus

Prometheus is an open-source monitoring and alerting tool designed to collect data about applications and systems. It also allows you to present that collected data in various forms, such as charts and graphs as well as issue real-time alerts to the relevant recipient when problems occurred.

The data about systems and applications that you want to monitor (CPU status, memory usage, request times, active connections, ...) is called a metric. Prometheus collects those metric data from monitoring objects (servers, databases, virtual machines, processes, ...) throughout your system at given intervals over HTTP and stores them in one place (locally or remotely).

In a little more detail, Prometheus collects and stores its metrics as time-series data (metrics information is stored along with the timestamp at when it was recorded) in a storage called time-series database (designed for time-series data). In its most basic form, a metric data point is made of: A metric name, The timestamp when the data point was collected, A measurement represented by a numeric value.

Monitoring is an important aspect of DevOps practices. In order to manage a big and complex system, you need to be able to quickly see what is happening in your systems. And through monitoring and collection of metric data, Prometheus allows you to do that. Those metrics provide insight into the behavior and health of your systems. If someone comes up to you and says the system is slow. You will need some informations to find out what is happening with it.

Example: Your server has slowed down significantly these days. Through query data from Prometheus and visualized into a chart, you can easily see that the server suddenly has an explosive high CPU Usage happening over the last 3 days. You start to check the processes and detect suspicious processes running in the background. Prometheus helped you detect the problem and the sooner a problem is detected, the sooner it can be fixed.

# Prometheus Components and Architecture

 Prometheus needs to fetch the metrics. Prometheus does this by sending a HTTP request called a scrape. The response to the scrape is parsed and ingested into storage. Several useful metrics are also added in, such as if the scrape succeeded and how long it took. Scrapes happen regularly; usually you would configure it to happen every 10 to 60 seconds for each target.

Prometheus discovers targets to scrape from service discovery. These can be your own instrumented applications or third-party applications you can scrape via an exporter. The scraped data is stored, and you can use it in dashboards using PromQL or send alerts to the Alertmanager, which will convert them into pages, emails, and other notifications.

• Prometheus Server: 

A central server that handles the scraping and storing of metric data. The server is also in charge of monitoring job scheduling. Monitoring jobs are set up using one or more "scrape config" directives, which are handled via a YAML configuration file.

• Exporters:

An exporter is a piece of software that you deploy right beside the application you want to obtain metrics from. It takes in requests from Prometheus, gathers the required data from the application, transforms them into the correct format, and finally returns them in a response to Prometheus.

Exporters can be thought of as "monitoring agents" that collect metrics from a specific system or application and make them available for collection by the Prometheus server. 

Prometheus collects metrics mainly using a pull model. This means the Prometheus server pulls metric data from exporters — agents do not push data to the Prometheus server.
  
For every major DevOps tool on the market, there is a specific exporter that exposes data in a format Prometheus can read. The most important of these is the Node Exporter, used to expose system metrics. 

• Client Libraries - turn your custom application into an exporter that exposes metrics in a format Prometheus can collect.
Client Libraries
Metrics do not typically magically spring forth from applications; someone has to add the instrumentation that produces them. This is where client libraries come in. With usually only two or three lines of code, you can both define a metric and add your desired instrumentation inline in code you control. 

Service Discovery
Once you have all your applications instrumented and your exporters running, Prometheus needs to know where they are. This is so Prometheus will know what is meant to monitor, and be able to notice if something it is meant to be monitoring is not responding. With dynamic environments you cannot simply provide a list of applications and exporters once, as it will get out of date. This is where service discovery comes in.

• Push Gateway - Allows pushing metrics to Prometheus for certain specific use cases. (e.g., Work with short-term processes when the service is running in a much too short time for Prometheus to be able to make requests to it to get metrics).

• Alertmanager - Sends alerts triggered by metric data to external system, such as: email, Slack, PagerDuty, ...).
The Alertmanager receives alerts from Prometheus servers and turns them into notifications. Notifications can include email, chat applications such as Slack, and services such as PagerDuty.


• Web UI & Visualization Tools - Provide useful ways to view metric data in a chart or graph form over time. However, Grafana are advised for actual graphs.
It is recommended that you use Grafana for dashboards. It has a wide variety of features, including official support for Prometheus as a data source. It can produce a wide variety of dashboards,
